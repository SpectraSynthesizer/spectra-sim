import "DwyerPatterns.spectra"
spec DiningPhilosophers     

type State = {FREE, LEFT, RIGHT};
define N := 5;
env boolean[N] hungry;
sys State[N] forks;
predicate hasTwoForks(Int(0..(N-1)) i):
	forks[i%N] = RIGHT & forks[(i+1)%N] = LEFT;

asm initialNoHungry: ini forall i in Int(0..(N-1)) . !hungry[i];

asm keepBeingHungry: always forall i in Int(0..(N-1)) . (hungry[i] & !hasTwoForks(i)) -> next(hungry[i]);

asm stopsEating{Int(0..(N-1)) i}: S_responds_to_P_globally(!hungry[i], hasTwoForks(i));

gar initialForksFree: ini forall i in Int(0..(N-1)) . forks[i] = FREE;

gar alwaysKeepForksWhileEating: always forall i in Int(0..(N-1)) . (hasTwoForks(i) & hungry[i]) -> (next(hasTwoForks(i)));

gar alwaysGiveLeftAndRightTogether: always forall i in Int(0..(N-1)) . (forks[i] = RIGHT <-> forks[(i+1)%N] = LEFT);

gar mustPutDownFork: always forall i in Int(0..(N-1)) . (forks[i] = LEFT -> next(forks[i]) != RIGHT) & (forks[i] = RIGHT -> next(forks[i]) != LEFT);

gar dontGiveForkIfNoHungry: always forall i in Int(0..(N-1)) . (!hungry[i] -> (next(forks[i] != RIGHT) & next(forks[(i+1)%N] != LEFT)));

gar eventuallyEats{Int(0..(N-1)) i}: S_responds_to_P_globally(hasTwoForks(i), hungry[i]);

// Vacuous Guarantees

//gar adjacentNeverEatTogether: always forall i in Int(0..(N-1)) . hasTwoForks(i) -> (!hasTwoForks(i+1) & !(hasTwoForks(i-1)));

//gar eventuallyNotEating{Int(0..(N-1)) i}: alwEv !hasTwoForks(i); 